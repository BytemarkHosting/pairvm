#!/usr/bin/ruby
#
# pairvm is a tool to manage virtual machines over pairs of co-operating
# servers to achieve high availability and simple failover.
#

require 'ipaddr'
require 'yaml'
require 'tempfile'

class IPAddr
  class << self
    # Returns the current list of IPs that this Linux machine is claiming
    # locally.  Will fail if not running on Linux.  Will return netmasks of
    # local LANs (masking actual IPs) if with_mask=true
    #
    def local(with_mask=false)
      raw = `/bin/ip addr show`
      raise "/bin/ip command failed" unless $?.exitstatus == 0
      regex = with_mask ? /inet6? ([^ ]+)/ : /inet6? ([^\/ ]+)/
      raw.split("\n").map do |line|
        md = regex.match(line)
        md ? IPAddr.new(md[1]) : nil
      end.compact
    end
  end
end

module PairVM
  #
  # A quick class to help us manipulate a YAML file as a database, re-reading
  # it every time.  The YAML must be a hash/dictionary at the top level.
  #
  class YAMLFileFront
    # Initialise the YAML file - if data is supplied, it is written in its
    # entirety to the given filename.  If data isn't supplied, the file must
    # exist and be parseable YAML.
    #
    def initialize(name, data=nil)
      @name = name
      if data
        raise Errno::EEXIST if File.exists?(name)
        write(data)
      else
        raise ArgumentError.new("#{name} does not exist") unless
          File.exists?(name)
      end
    end

    # The name of this file, equivalent to the last component of its path
    #
    def name
      @name.split("/")[-1]
    end

    protected

    # read a key from the file
    def get(key)
      YAML::parse(File.read(@name)).transform[key]
    end

    # set a key to a new value
    def set(key, value)
      data = YAML::parse(File.read(@name)).transform
      data[key] = value
      write
    end

    # utility to safely write the entire data back to @name
    def write(data)
      tmp = "#{@name}.#{$$}.#{rand(9999999)}"
      begin
        File.open(tmp, "w") { |fh| fh.write(data.to_yaml) }
        File.rename(tmp, @name)
      ensure
        File.unlink(tmp) if File.exists?(tmp)
      end
    end
  end

  # Gives us the status of a particular machine's KVM process (running or not)
  # and allows us to start and stop it.
  #
  class KVM
    # Initialise an object that tracks the KVM process for the given Machine.
    #
    def initialize(machine)
      @machine = machine.kind_of?(Machine) ? machine : Machine.new(machine)
    end
    
    # Returns true if the KVM process is running, false otherwise.
    #
    def running?
      return true if pid
    end
    
    # Start this KVM process according to the machine's current settings, and
    # those found in Global.  Machine must not be running already.
    #
    def start!(extra_options)
      raise "KVM for #{@machine.name} is already running" if
        running?
      Commands.system(*(command_line + extra_options))
    end
    
    # Forcefully stops the KVM process, which must be running
    # 
    def stop!
      raise "KVM for #{@machine.name} is not running" if
        !running?
      Process.kill("TERM", pid)
    end
    
    # the name of the monitor socket we use for the running KVM, based on the
    # Machine's name.
    def monitorfile
      "/machines/.#{@machine.name}.monitor"
    end
    
    protected
    # The PID for the currently running KVM.  Returns nil if it's not running,
    # and cleans up any stale PID in the process.
    #
    def pid
      begin
        my_pid = File.read(pidfile).to_i
      rescue Errno::ENOENT
        return nil
      end
      if File.exists?("/proc/#{my_pid}")
        return my_pid
      end
      File.unlink(pidfile)
      nil
    end    
    
    # the name of the pidfile we use, based on the Machine's name
    def pidfile
      "/machines/.#{@machine.name}.pid"
    end
    
    # return a suitable command line for starting the KVM
    def command_line
      me = File.expand_path($0)
      [Global.kvm,
       "-daemonize",
       "-pidfile", pidfile,
       "-monitor", "unix:#{monitorfile},server,nowait",
       "-drive", "file=#{@machine.drbd.node},if=virtio",
       "-m", @machine.memory.to_s,
       "-vnc", "127.0.0.1:"+@machine.vnc_screen.to_s,
       "-balloon", "virtio",
       # FIXME: mistake in kvm docs, says name= instead of ifname=
       "-net", "tap,ifname=#{@machine.name},script=#{me}_tap_up,downscript=#{me}_tap_down",
       "-net", "nic,name=#{@machine.name}",
       "-bios", "/root/bios.bin" # FIXME: configure somewhere
      ] +
      # FIXME: need to be any cleverer in merging options?
      @machine.kvm_options.split(" ")
    end
  end

  # Some convenience methods to configure system DRBD state, and return
  # information about each configured device
  #
  class DRBD
    class << self
      # Parses /proc/drbd and returns an array of hashes, one  for each 
      # configured DRBD.
      #
      def all_raw
        # this got out of hand for all the use it's going to get
        File.open("/proc/drbd") { |fh| fh.readline; fh.readline; fh.read }.
          split(/\n[\d ]\d: (?=cs)/).
          map do |raw_info|
            info = {}
            raw_info.split("\n").each do |line|
              prefix_md = /\t([a-z]+): (.*)/.match(line)
              prefix = ""
              if prefix_md
                prefix= prefix_md[1] + "_"
                line = prefix_md[2]
              end
              current_key = nil
              line.split(/\s+/).each do |word|
                if /([a-z\']+):(.*)/.match(word)
                  word = $2
                  current_key = prefix+$1
                end
                next unless current_key
                if info.has_key?(current_key)
                  info[current_key] += " "+word
                else
                  info[current_key] = word
                end
              end
            end
            info
          end
      end
 
      # The number of currently-configured DRBDs on the system.
      def length
        all_raw.length
      end
    end

    # Initialise an object to track and control the numbered DRBD.  Will 
    # create the device node automatically if create is set to true.
    #
    def initialize(num, create=true)
      @num = num
      if !File.blockdev?(node)
        if create
          # no-op for a new device, causes it to be created
          setup("disconnect", "--create-device")
        else
          raise "drbd#{num} not configured"
        end
      end
    end

    # Allow access to any of the stats in /proc/drbd for this numbered DRBD
    # via method_missing - e.g. DRBD#cs will return "Unconfigured" for a new
    # device.
    def method_missing(method, *args)
      DRBD.all_raw[@num][method.to_s]
    end

    # Front to drbdsetup - automatically supplies the device node, and 
    # converts all arguments to strings, e.g. DRBD.new(0).setup("primary") will
    # likely call "drbdsetup /dev/drbd0 primary".
    #
    def setup(command, *args)
      Commands.system(
        *(["drbdsetup", node, command] + args.map { |a| a.to_s })
      )
    end
    
    # Returns true if the device node exists, and is configured with some
    # disk/net settings.  We generally use this to determine whether it's safe 
    # to reconfigure a DRBD.
    # 
    def configured?
      @num < DRBD.length && self.cs != "Unconfigured"
    end
    
    # The /dev node corresponding to this DRBD.
    # 
    def node
      "/dev/drbd#{@num}"
    end

    # Waits for the DRBD to reach the given connection state, returning
    # true if it got there, or false if it timed out.
    # 
    def wait_for_state(desired_state, timeout=2)
      started = Time.now
      while Time.now < started+timeout
        return true if self.cs == desired_state
      end
      false
    end
  end

  # We keep our global settings in a YAML file called /machines/_global.  This
  # contains all the information about the pair of VM hosts, and the resources
  # available to their VMs.  Global settings can be accessed as e.g. Global.ips
  #
  class Global < YAMLFileFront
    class << self
      def singleton; @instance ||= Global.new; end

      def method_missing(method, *args)
        singleton.__send__(method, *args)
      end
    end

    def initialize
      super("/machines/_global")
      # try to validate our cofiguration a little bit, "drbdsetup net"
      # silently fails if you give it duff IPs.
      
      raise ArgumentError.new("'here' IP isn't available locally") unless
        IPAddr.local.member?(ips['here'])
      raise ArgumentError.new("'here_drbd' IP isn't available locally") unless
        IPAddr.local.member?(ips['here_drbd'])
    end

    def ips; Hash[*get('ips').map { |k,v| [k,IPAddr.new(v)]  }.flatten]; end
    def drbd_ports
      Range.new(*get('drbd_ports').split(/[^\d]+/, 2).map { |s| s.to_i })
    end
    def kvm; get('kvm') || "/usr/bin/kvm"; end
    def kvm_options; get('kvm_options') || ""; end
    def max_memory
      get('max_memory') || (File.read("/proc/meminfo").split("\n")[0].split(/\s+/)[1].to_i >> 10) - 1000
    end
  end

  #
  # Settings for an individual virtual machine
  #
  class Machine < YAMLFileFront
    # Returns all Machines that we know about
    class << self
      def all
        Dir.new("/machines").
          select { |e| /^[a-z0-9]+$/.match(e) }.
          map { |e| Machine.new(e) }
      end
      
      # Returns the total amount of memory used
      #
      def total_memory(list_all=true)
        all.
          select { |machine| list_all || machine.at_home? }.
          inject(0) { |sum,machine| sum + machine.memory }
      end
      
      def total_memory_here(reverse=false)
        all.select { |machine| reverse ^ machine.at_home? }.
          inject(0) { |sum,machine| sum + machine.memory }
      end
      def total_memory_there
        total_memory_here(true)
      end
      def total_memory
        total_memory_here + total_memory_there
      end
      
      # Pick an unused DRBD port given the configured global range of DRBD 
      # ports.
      def allocate_drbd_port 
        (Global.drbd_ports.to_a - all.map { |m| m.drbd_port })[0]
      end
      
      # Pick an unused VNC screen number (we assume we can use 0 to 200).
      def allocate_vnc_screen
        ((0..200).to_a - all.map { |m| m.vnc_screen })[0]
      end
      
      # Pick an unallocated IP address from the public range, excluding the
      # first 6.
      #
      # FIXME: how to exclude IPs from other pairs of VM hosts that share
      # our public VLAN?
      # 
      def allocate_ip
        range = Global.ips['public']
        used = all.map { |m| m.ip }
        current = range.to_i + 6 # leave first 6 IPs free for routers
        current_ip = nil
        begin
          current_ip = IPAddr.new(current, Socket::AF_INET)
          return current_ip.to_s unless used.member?(current_ip)
          current += 1
        end while range.include?(current_ip)
        nil # nothing free
      end
    end

    def initialize(machine, data=nil)
      raise ArgumentError.new("Machine name must consist of a-z, 0-9 only") unless
        /^[a-z0-9]+$/.match(machine)
      super("/machines/#{machine}", data)
    end

    def suppress?; get('suppress').to_i == 1; end
    def suppress(suppress); set('suppress', suppress ? 1 : 0); end

    def memory; get('memory').to_i; end

    def home_machine; IPAddr.new(get('home_machine')); end
    def home_machine=(i); set('home_machine', IPAddr.new(i)); end

    def drbd_port; get('drbd_port').to_i; end
    def kvm_options; get('kvm_options'); end
    def vnc_screen; get('vnc_screen'); end
    
    def ip; IPAddr.new(get('ip')); end

    # Returns true if we are running on our configured "home" machine
    #
    def at_home?
      home_machine_cache = home_machine # pointless repeated reloads
      IPAddr.local.member?(home_machine_cache)
    end
    
    # Returns the DRBD object for this VM
    # 
    def drbd
      DRBD.new(drbd_node_number)
    end

    # Returns the drbd device we should be using for this VM
    #
    def drbd_node_number
      drbd_port - Global.drbd_ports.first
    end

    # Returns the expected backing device for this VM
    #
    def drbd_backing_device
      here_or_there = at_home? ? "here" : "there"
      "/dev/#{here_or_there}/#{name}"
    end

    # Returns the backing device for this VM's DRBD metadata
    #
    def drbd_meta_device
      drbd_backing_device + "_meta"
    end
    
    # Do the setup for this machine's DRBD (disk and net) - will fail if the
    # DRBD is already configured.
    # 
    def drbd_connect!(discard_my_data=false)
      drbd.setup("disk", drbd_backing_device, drbd_meta_device, 0)
      net_args = [
        "#{Global.ips['here_drbd']}:#{drbd_port}",
        "#{Global.ips['there_drbd']}:#{drbd_port}",
        "C",
        "--after-sb-0pri", "discard-zero-changes",
        "--after-sb-1pri", "consensus",
        "--after-sb-2pri", "disconnect"
      ]
      net_args += ["--discard-my-data"] if discard_my_data
      drbd.setup("net", *net_args)
    end
    
    # Returns a KVM object for tracking whether this Machine is actually
    # running or not.
    # 
    def kvm
      @kvm ||= KVM.new(self)
    end
    
    # Returns the number of bytes for this VM's disc
    #
    def disc_size
      File.open(drbd_backing_device) { |fh| fh.seek(0,IO::SEEK_END); fh.tell }
    end
  end

  # Command line parser
  #
  module Commands
    class << self
      # Report an error and stop running
      # 
      def error(msg, exception=nil)
        if exception
          STDERR.print "*** #{exception}\n"
          exception.backtrace.each do |line|
            STDERR.print "* #{line}\n"
          end
        end
        STDERR.print("*** #{msg}\n")
        exit 1
      end
      
      # 
      #
      def verbose(msg)
        STDERR.print "#{msg}\n" if @verbose
      end

      # Changes system to throw an exception if it fails
      #
      def system(*args)
        if !Kernel::system(*args)
          STDERR.print "*** Error running #{args.join(' ')}\n"
          exit 2
        else
          verbose "system: "+args.join(" ")
        end
      end

      # Turn our command line into execution of a method
      #
      def parse(*args)
        error("No command provided") if args.empty?
        if /-v|--verbose/.match(args[0])
          args.shift
          @verbose = true
        end
		args[0] = "help" if /-h|--help|/.match(args[0])
		
        cmd = args.shift
        cmd_sym = "cmd_#{cmd}".to_sym
        error("No such command '#{cmd}'") unless respond_to?(cmd_sym)
		begin
          __send__(cmd_sym, *args)
		rescue ArgumentError => ex
		  # assume the user can fix these, report them nicely
		  help_sym = "help_#{cmd}".to_sym
		  raise unless respond_to?(help_sym)
		  error(ex.to_s)
		end
      end
	  
	  def help_create; [
	    "Creates a new virtual machine",
	    ["name", "here|there|IP", "memory", "disc_size"],
		["ip", "drbd_port", "kvm_options", "vnc_screen"],
		{ "name" => "The name of the VM (15 chars max)",
		  "here|there|IP" => "The IP of the machine to run on (or 'here' or 'there')",
		  "memory" => "The number of megabytes of memory to allocate",
		  "disc_size" => "The size of disc to allocate (include prefix, e.g. 50G)",
		  "ip" => "The IP address to use (default is to auto-allocate)",
		  "drbd_port" => "The DRBD port to use (default is to auto-allocate)",
		  "kvm_options" => "Any permanent KVM options for this VM (default is empty)",
		  "vnc_Screen" => "The VNC screen number (default is to auto-allocate)"
		}
	  ]; end
	  
      def cmd_create(name, here_or_there, mem, disc_size, ip=nil, drbd_port=nil, kvm_options="", vnc_screen=nil)
        if !/^t?here$/.match(here_or_there)
          if here_or_there == Global.ips['here'].to_s
            here_or_there == "here"
          elsif here_or_there == Global.ips['there'].to_s
            here_or_there =  "there"
          else
            error("Must supply 'here' or 'there' or IP address ('#{here_or_there}' is none of those)")
          end
        end
        
        is_here = (here_or_there == "here")
        mem = mem.to_i
        
        # Don't FIXME: allow stymied user to override
        mem_left = Global.max_memory/2 - (is_here ? Machine.total_memory_here : Machine.total_memory_there)
        error("Won't use >50% of the memory on this host (must be < #{mem_left}M)") if 
          is_here && Machine.total_memory_here + mem > Global.max_memory/2
        error("Won't use >50% of the memory on the other host  (must be < #{mem_left}M)") if
          !is_here && Machine.total_memory_there + mem > Global.max_memory/2

        drbd_port ||= Machine.allocate_drbd_port
        vnc_screen ||= Machine.allocate_vnc_screen
        ip ||= Machine.allocate_ip
        
        error("No DRBD ports left to allocate") unless drbd_port
        error("No VNC screens  left to allocate") unless vnc_screen
        error("No IP addresses left to allocate") unless ip

        # Create our logical volumes - 10MB metadata is enough for a device
        # size of 32TB.  drbd name seems to be ignored for the 'create-md'
        # command, but it needs to be valid, and not configured.
        #
        system("lvcreate -n#{name} -L#{disc_size} #{here_or_there}")
        system("lvcreate -n#{name}_meta -L128M #{here_or_there}")
        system("drbdmeta --force /dev/drbd9999999999 "+
          "v08 /dev/#{here_or_there}/#{name}_meta 0 create-md"
        )

        verbose "creating #{name}"
        machine = Machine.new(name, {
          "ip" => ip,
          "suppress" => 1,
          "home_machine" => Global.ips[is_here ? 'here' : 'there'].to_s,
          "drbd_port" => drbd_port.to_i,
          "kvm_options" => kvm_options,
          "vnc_screen" => vnc_screen.to_i,
          "memory" => mem
        })
        
        verbose "running drbd setup"
        machine.drbd_connect!
        if machine.at_home?
          machine.drbd.setup("primary", "-o")
        else
          machine.drbd.setup("invalidate")
        end
        
        # FIXME: ssh and run same command on other host would be helpful
      end
	  
	  def help_start; [
	    "Starts a virtual machine running on this host",
		["name"],
		["--away", "--disconnected", "--kvm-options"],
		{ "name" => "The name of the VM",
		  "--away" => "Force VM to run when not on its home machine",
		  "--disconnected" => "Force VM to run without replicating to peer",
		  "--kvm-options <options...>" => "Extra KVM options for this boot"
		}
	  ]; end

      def cmd_start(name, *options)
        machine = Machine.new(name)

        away = false
        disconnected = false
        kvm_options = []

        while !options.empty?
          o = options.shift
          case o
            when "--away" then away = true
            when "--disconnected" then disconnected = true
            when "--kvm-options"
              kvm_options = options
              options = []
              break
            else
              error "Unknown option #{o}"
          end
        end
        
        verbose "starting #{name} #{machine.at_home? ? 'at home' : 'away'}"+
          " away=#{away} destroy_peer=#{disconnected}"

        error "#{name} is not meant to run here, you must add "+
          "'--away' to run it away from home" unless 
          machine.at_home? || away

        machine.drbd.setup("down")
        machine.drbd_connect!

        if !machine.drbd.wait_for_state("Connected")
          if machine.drbd.cs == "StandAlone"
            error "DRBD device #{machine.drbd.node} is StandAlone which "+
              "suggests a split brain.  Run 'split_brain_victim' on one peer "+
              "or the other to erase its data and resolve the situation."
          elsif !disconnected
            error "DRBD device #{machine.drbd.node} is not connected - use "+
              "--disconnected if you want to run without the peer (risking "+
              "split brain later)."
          end
        end
        
        # If we don't wait for DRBD to connect before we switch to primary,
        # we risk a split brain.
        machine.drbd.setup("primary")
        
        if !machine.kvm.running?
          print "Starting #{machine.name}\n"
          machine.kvm.start!(kvm_options)
        end
      end
	  
	  def help_tap_up; [
	    "Used internally by qemu to start network interface after KVM startup"
		["name"],
		[],
		{ "name" => "The name of the VM (and network interface)" }
	  ]; end

      def cmd_tap_up(name)
        system "ip link set #{name} up promisc on"
        system "brctl addif br0 #{name}"
      end
	  
	  def help_tap_down; [
	    "Used internally by qemu to stop network interface after KVM shutdown"
		["name"],
		[],
		{ "name" => "The name of the VM (and network interface)" }
	  ]; end

      def cmd_tap_down(name)
        machine = Machine.new(name)
        system "brctl delif br0 #{name}"
        system "ip link set #{name} down"
        # make sure the other host can become primary without a fight before
        # we switch off
        machine.drbd.setup("secondary")
      end
	  
	  def help_drbd_listen; [
	    "Set up DRBD for given machine in secondary role"
		["name"],
		[],
		{ "name" => "The name of the VM" }
	  ]; end
	  
      def cmd_drbd_listen(name)
        machine = Machine.new(name)
        machine.drbd_connect! unless machine.drbd.configured?
        machine.drbd.setup("secondary")
      end
	  
	  def help_split_brain_victim; [
	    "Designate the VM data on this host as a 'split brain victim' and erase it to resume replication"
		["name"],
		[],
		{ "name" => "The name of the VM" ,
		  "snapshot_size" => "The size of the snapshot to create before erasing the data"
		}
	  ]; end
	  
      def cmd_split_brain_victim(name, snapshot_size="5G")
        machine = Machine.new(name)

        lv_name = machine.name + "_split_" +
          Time.now.strftime("%Y%m%d%H%M%S")
        system("lvcreate -n#{lv_name} -L#{snapshot_size} -s #{machine.drbd_backing_device}")

        machine.drbd.setup("down")
        machine.drbd_connect!(true) # do the damage now we have a backup

        verbose "Created snapshot #{lv_name}, original will now be overwritten by peer"
      end
	  
	  def help_stop; [
	    "Immediately kill the given VM (power off)"
		["name"],
		[],
		{ "name" => "The name of the VM" }
	  ]; end
	        
      def cmd_stop(name)
        Machine.new(name).kvm.stop!
      end

      # Start any VM that is meant to be started, or drbd listening for those
      # that aren't.
      #
      def cmd_autostart(*names)
        machines = names.empty? ? Machine.all : names.map { |m| Machine.new(m) }
        machines.each do |machine|
          begin
            if machine.at_home?
              cmd_start(machine.name)
            else
              cmd_drbd_listen(machine.name)
            end
          rescue Exception => ex
            error("Could not autostart VM #{name}", ex)
          end
        end
      end

      def cmd_suppress(name, do_suppress)
        Machine.new(name).suppress = do_suppress
      end
      
      def cmd_monitor(name)
        exec("/usr/bin/socat", "-", Machine.new(name).kvm.monitorfile)
      end
      
      def cmd_list
        print "Name            Memory Disc Run?    Home?   VNC\n"
        Machine.all.each do |machine|
          printf "%-15s %-6s %-4s %-s %-s :%-3d \n", 
            machine.name, 
            machine.memory.to_s + "M",
            (machine.disc_size >> 30).to_s + "G",
            machine.kvm.running? ?  "Running" : "Stopped",
            machine.at_home? ? "at home" : "away   ",
            machine.vnc_screen
        end
        
        print "\nTotal RAM here: #{Machine.total_memory_here}M "+
          "there: #{Machine.total_memory_there}M "+
          "max: #{Global.max_memory}M\n"
      end

      def cmd_print_ssh_forwards(offset=0)
        offset = offset.to_i
        print "OpenSSH port forwards (cut & paste): "
        num = 0
        machines = Machine.all.select { |m| m.kvm.running? }
        machines.each do |machine|
          print "-L #{5900+offset+num}:localhost:#{5900+machine.vnc_screen} "
          num += 1
        end
        print "\n"
        num = 0
        machines.each do |machine|
          print "#{machine.name} is on VNC localhost:#{offset+num}\n"
        end
      end
    end
  end
end

me = File.expand_path($0)
if /_tap_(up|down)$/.match(me)
  PairVM::Commands.parse("tap_#{$1}", ARGV[0])
else
  File.open("/machines/_global") do |lockfile|
    # Script must be callable by two aliases for qemu network scripts to work
    # - if this fails, you'll need to do it yourself.
    File.symlink(me, me+"_tap_up") unless File.symlink?(me+"_tap_up")
    File.symlink(me, me+"_tap_down") unless File.symlink?(me+"_tap_down")
    
    # there's nothing safe about running two of this script
    lockfile.flock(File::LOCK_EX)
    begin
      PairVM::Commands.parse(*ARGV)
    ensure
      lockfile.flock(File::LOCK_UN)
    end
  end
end

