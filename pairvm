#!/usr/bin/ruby
#
# pairvm is a tool to manage virtual machines over pairs of co-operating
# servers to achieve high availability and simple failover.
#
# (C) Bytemark Hosting 2010-12, distributable under the terms of the
# GNU General Public License version 3 or later.
#
# To install on a Debian/squeeze system:
# * copy to /usr/local/sbin
# * apt-get install ruby

require 'ipaddr'
require 'yaml'
require 'tempfile'
require 'timeout'
require 'digest/md5'

begin
  require 'rubygems'
  require 'bytemark_installer/pairvm'
rescue LoadError
end

class IPAddr
  class << self
    # Returns the current list of IPs that this Linux machine is claiming
    # locally.  Will fail if not running on Linux.  Will return netmasks of
    # local LANs (masking actual IPs) if with_mask=true
    #
    def local(with_mask=false)
      raw = `/bin/ip addr show`
      raise "/bin/ip command failed" unless $?.exitstatus == 0
      regex = with_mask ? /inet6? ([^ ]+)/ : /inet6? ([^\/ ]+)/
      raw.split("\n").map do |line|
        md = regex.match(line)
        md ? IPAddr.new(md[1]) : nil
      end.compact
    end
  end
end

module PairVM
  #
  # A quick class to help us manipulate a YAML file as a database, re-reading
  # it every time.  The YAML must be a hash/dictionary at the top level.
  #
  class YAMLFileFront
    # Initialise the YAML file - if data is supplied, it is written in its
    # entirety to the given filename.  If data isn't supplied, the file must
    # exist and be parseable YAML.
    #
    def initialize(name, data=nil)
      @name = name
      if data
        raise Errno::EEXIST if File.exists?(name)
        write(data)
      else
        raise ArgumentError.new("#{name} does not exist") unless
          File.exists?(name)
      end
    end

    # The name of this file, equivalent to the last component of its path
    #
    def name
      @name.split("/")[-1]
    end

    # generate an MD5 digest from the file, ignoring comments, and any
    # keys to be excluded.
    def digest(*exclude)
      data = YAML::load(File.read(@name))
      exclude.each { |key| data.delete(key) }
      Digest::MD5.hexdigest(data.to_a.sort.to_s)
    end

    # return the contents of the YAML backing file
    def yaml
      File.read(@name)
    end

    protected

    # read a key from the file
    def get(key)
      YAML::parse(File.read(@name)).transform[key]
    end

    # set a key to a new value
    def set(key, value)
      data = YAML::parse(File.read(@name)).transform
      data[key] = value
      write(data)
    end

    # utility to safely write the entire data back to @name
    def write(data)
      tmp = "#{@name}.#{$$}.#{rand(9999999)}"
      begin
        File.open(tmp, "w") { |fh| fh.write(data.to_yaml) }
        File.rename(tmp, @name)
      ensure
        File.unlink(tmp) if File.exists?(tmp)
      end
    end
  end

  # Gives us the status of a particular machine's KVM process (running or not)
  # and allows us to start and stop it.
  #
  class KVM
    # Initialise an object that tracks the KVM process for the given Machine.
    #
    def initialize(machine)
      @machine = machine.kind_of?(Machine) ? machine : Machine.new(machine)
    end

    # Returns true if the KVM process is running, false otherwise.
    #
    def running?
      return true if pid
    end

    # Start this KVM process according to the machine's current settings, and
    # those found in Global.  Machine must not be running already.
    #
    def start!(extra_options)
      raise "KVM for #{@machine.name} is already running" if
        running?
      Commands.system(*(command_line + extra_options))
    end

    # Forcefully stops the KVM process, and wait for it to terminate
    #
    def stop!
      raise "KVM for #{@machine.name} is not running" if
        !running?
      Process.kill("TERM", pid)
      give_up_at = Time.now + 10
      sleep 0.25 while !pid.nil? && Time.now < give_up_at
      return unless pid
      raise "KVM process #{pid} would not terminate when asked politely"
    end

    # the name of the monitor socket we use for the running KVM, based on the
    # Machine's name.
    def monitorfile
      "/machines/.#{@machine.name}.monitor"
    end

    # the name of the UNIX socket connected to the VM's serial port,
    # based on the Machine's name.
    def serialfile
      "/machines/.#{@machine.name}.serial"
    end

    # run the given monitor command
    def monitor_cmd(line)
      UNIXSocket.open(monitorfile) do |m|
        m.sync = true
        timeout(60) { expect(m, "(qemu) ") }
        m.write(line+"\n")
        return expect(m, "(qemu) ")[0..-8]
      end
    end

    # The PID for the currently running KVM.  Returns nil if it's not running,
    # and cleans up any stale PID in the process.
    #
    def pid
      begin
        my_pid = File.read(pidfile).to_i
      rescue Errno::ENOENT
        return nil
      end
      if File.exists?("/proc/#{my_pid}")
        return my_pid
      end
      File.unlink(pidfile)
      nil
    end

    protected

    def expect(socket, string)
      buffer = ""
      while buffer[-string.length..-1] != string
        buffer += socket.read(1)
      end
      buffer
    end

    # the name of the pidfile we use, based on the Machine's name
    def pidfile
      "/machines/.#{@machine.name}.pid"
    end

    # return a suitable command line for starting the KVM
    def command_line
      me = File.expand_path($0)
      [Global.kvm,
      "-daemonize",
      "-pidfile", pidfile,
      "-monitor", "unix:#{monitorfile},server,nowait",
      "-serial", "unix:#{serialfile},server,nowait",
      "-drive", "file=#{@machine.drbd.node},if=#{@machine.driver_disk}",
      "-m", @machine.memory.to_s,
      "-vnc", "127.0.0.1:"+@machine.vnc_screen.to_s,
      "-balloon", "virtio",
      # FIXME: mistake in kvm docs, says name= instead of ifname=
      "-net", "tap,ifname=#{@machine.name},script=#{me}_tap_up,downscript=#{me}_tap_down",
      "-net", "nic,name=#{@machine.name},model=#{@machine.driver_net},macaddr=#{@machine.macaddr}",
      "-bios", "/root/bios.bin" # FIXME: configure somewhere
      ] +
      command_line_incoming +
      # FIXME: need to be any cleverer in merging options?
      @machine.kvm_options.split(" ")
    end

    # Add command line options to KVM to take a memory dump file into account,
    # if we have one.  Otherwise remove one if it's outdated.
    #
    def command_line_incoming
      if File.file?(@machine.memory_dump_file)
        if Time.now - File.stat(@machine.memory_dump_file).mtime < 120
          return ["-incoming", "exec: gzip -c -d #{@machine.memory_dump_file}"]
        else
          File.unlink(@machine.memory_dump_file)
        end
      end
      []
    end
  end

  # Some convenience methods to configure system DRBD state, and return
  # information about each configured device
  #
  class DRBD
    class << self
      # Parses /proc/drbd and returns an array of hashes, one  for each
      # configured DRBD.
      #
      def all_raw
        # this got out of hand for all the use it's going to get
        raw = []
        File.open("/proc/drbd") { |fh| fh.readline; fh.readline; fh.read }.
          split(/\n(?=[\d ]+\d: cs)/).
          each do |raw_info|
            number = raw_info.to_i
            info = {}

            raw_info.split("\n").each do |line|
              prefix_md = /\t([a-z]+): (.*)/.match(line)
              prefix = ""
              if prefix_md
                prefix= prefix_md[1] + "_"
                line = prefix_md[2]
              end
              current_key = nil
              line.split(/\s+/).each do |word|
                if /([a-z\']+):(.*)/.match(word)
                  word = $2
                  current_key = prefix+$1
                end
                next unless current_key
                if info.has_key?(current_key)
                  info[current_key] += " "+word
                else
                  info[current_key] = word
                end
              end
            end

            raw[number] = info
          end
        raw
      end

      # The number of currently-configured DRBDs on the system.
      def length
        all_raw.length
      end
    end

    # Initialise an object to track and control the numbered DRBD.  Will
    # create the device node automatically if create is set to true.
    #
    def initialize(num, create=true)
      @num = num
      # I don't like this - but maybe drbdadm does something similar
      if create
        Commands.system("mknod", node, "b", 147, num) unless File.blockdev?(node)
        Kernel::system("/sbin/drbdsetup #{node} resume-io --create-device 2>&1")
      else
        raise "drbd#{num} not configured"
      end
    end

    # Allow access to any of the stats in /proc/drbd for this numbered DRBD
    # via method_missing - e.g. DRBD#cs will return "Unconfigured" for a new
    # device.
    def method_missing(method, *args)
      DRBD.all_raw[@num][method.to_s]
    end

    # Front to drbdsetup - automatically supplies the device node, and
    # converts all arguments to strings, e.g. DRBD.new(0).setup("primary") will
    # likely call "drbdsetup /dev/drbd0 primary".
    #
    def setup(command, *args)
      Commands.system(
        *(["/sbin/drbdsetup", node, command] + args.map { |a| a.to_s })
      )
    end

    # Returns true if the device node exists, and is configured with some
    # disk/net settings.  We generally use this to determine whether it's safe
    # to reconfigure a DRBD.
    #
    def configured?
      @num < DRBD.length && self.cs != "Unconfigured"
    end
    
    def primary?
      @num < DRBD.length && /^Primary/.match(ro)
    end

    # The /dev node corresponding to this DRBD.
    #
    def node
      "/dev/drbd#{@num}"
    end

    # Waits for the DRBD to reach one of the given connection states, returning
    # true if it got there, or false if it timed out.
    #
    def wait_for_states(*desired_states)
      wait_until = Time.now + 10
      while Time.now < wait_until
        return true if desired_states.member?(self.cs)
        sleep 1
      end
      false
    end
  end

  # We keep our global settings in a YAML file called /machines/_global.  This
  # contains all the information about the pair of VM hosts, and the resources
  # available to their VMs.  Global settings can be accessed as e.g. Global.ips
  #
  class Global < YAMLFileFront
    class << self
      def singleton; @instance ||= Global.new; end

      def method_missing(method, *args)
        singleton.__send__(method, *args)
      end
    end

    def initialize
      super("/machines/_global")
      # try to validate our cofiguration a little bit, "drbdsetup net"
      # silently fails if you give it duff IPs.

      raise ArgumentError.new("'here' IP isn't available locally") unless
        IPAddr.local.member?(ips['here'])
      raise ArgumentError.new("'here_drbd' IP isn't available locally") unless
        IPAddr.local.member?(ips['here_drbd'])
    end

    def ips; Hash[*get('ips').map { |k,v| [k,IPAddr.new(v)]  }.flatten]; end
    def drbd_ports
      Range.new(*get('drbd_ports').split(/[^\d]+/, 2).map { |s| s.to_i })
    end
    def kvm; get('kvm') || "/usr/bin/kvm"; end
    def kvm_options; get('kvm_options') || ""; end
    def max_memory
      get('max_memory') || (File.read("/proc/meminfo").split("\n")[0].split(/\s+/)[1].to_i >> 10) - 1000
    end
  end

  #
  # Settings for an individual virtual machine
  #
  class Machine < YAMLFileFront
    # Returns all Machines that we know about
    class << self
      def all
        Dir.new("/machines").
          select { |e| /^[a-z0-9\-]+$/.match(e) }.
          map { |e| Machine.new(e) }.
          sort
      end

      # Returns the total amount of memory used
      #
      def total_memory(list_all=true)
        all.
          select { |machine| list_all || machine.at_home? }.
          inject(0) { |sum,machine| sum + machine.memory }
      end

      def total_memory_here(reverse=false)
        all.select { |machine| reverse ^ machine.at_home? }.
          inject(0) { |sum,machine| sum + machine.memory }
      end
      def total_memory_there
        total_memory_here(true)
      end
      def total_memory
        total_memory_here + total_memory_there
      end

      # Pick an unused DRBD port given the configured global range of DRBD
      # ports.
      def allocate_drbd_port
        (Global.drbd_ports.to_a - all.map { |m| m.drbd_port })[0]
      end

      # Pick an unused VNC screen number (we assume we can use 0 to 200).
      def allocate_vnc_screen
        ((0..200).to_a - all.map { |m| m.vnc_screen })[0]
      end

      # Pick an unallocated IP address from the public range, excluding the
      # first 6.
      #
      # FIXME: how to exclude IPs from other pairs of VM hosts that share
      # our public VLAN?
      #
      def allocate_ip
        range = Global.ips['public']
        used = all.map { |m| m.ip }
        current = range.to_i + 6 # leave first 6 IPs free for routers
        current_ip = nil
        begin
          current_ip = IPAddr.new(current, Socket::AF_INET)
          return current_ip.to_s unless used.member?(current_ip)
          current += 1
        end while range.include?(current_ip)
        nil # nothing free
      end
    end

    def <=>(b); self.name <=> b.name; end

    def initialize(machine, data=nil)
      raise ArgumentError.new("Machine name must be 3-15 chars, consist of a-z, 0-9, and - only") unless
        /^[a-z0-9\-]{3,15}$/.match(machine)
      super("/machines/#{machine}", data)
    end
      
    def lock
      @lockfile ||= File.open("/machines/#{name}")
      raise "Machine #{name} locked" if 
        @lockfile.flock(File::LOCK_EX | File::LOCK_NB) == false &&
        !ENV['PAIRVM_IGNORE_LOCK']
    end
    
    def unlock
      raise "Couldn't unlock" unless @lockfile
      @lockfile.flock(File::LOCK_UN)
    end

    def digest
      super('macaddr')
    end

    def suppress?; get('suppress').to_i == 1; end
    def suppress(suppress); set('suppress', suppress ? 1 : 0); end

    def memory; get('memory').to_i; end

    def home_machine; IPAddr.new(get('home_machine')); end
    def home_machine=(i); set('home_machine', IPAddr.new(i)); end

    def drbd_port; get('drbd_port').to_i; end
    def kvm_options; get('kvm_options'); end
    def vnc_screen; get('vnc_screen'); end

    def ip; IPAddr.new(get('ip')); end

    def driver_net; get('driver_net') || 'virtio'; end
    def driver_disk; get('driver_disk') || 'virtio'; end

    def macaddr;
      mac = get('macaddr')
      set('macaddr', mac = sprintf("%02x:%02x:%02x:%02x:%02x:%02x",
        2, 0,
        Global.ips['here'].to_i & 255,
        Global.ips['there'].to_i & 255,
        (vnc_screen >> 8) & 255,
        vnc_screen & 255
      )) unless mac
      mac
    end

    def bridge
      get('bridge') || 'br0'
    end

    # Returns true if we are running on our configured "home" machine
    #
    def at_home?
      home_machine_cache = home_machine # pointless repeated reloads
      IPAddr.local.member?(home_machine_cache)
    end

    # Returns true if we are running on our configured "away" machine
    #
    def away?
      !at_home?
    end

    # Returns the DRBD object for this VM
    #
    def drbd
      DRBD.new(drbd_node_number)
    end

    # Returns the drbd device we should be using for this VM
    #
    def drbd_node_number
      drbd_port - Global.drbd_ports.first
    end

    # Returns the expected backing device for this VM
    #
    def drbd_backing_device
      here_or_there = at_home? ? "here" : "there"
      "/dev/#{here_or_there}/#{name}"
    end

    # Returns the expected backing device for this VM on the other host
    #
    def drbd_backing_device_there
      here_or_there = at_home? ? "there" : "here"
      "/dev/#{here_or_there}/#{name}"
    end

    # Returns the backing device for this VM's DRBD metadata
    #
    def drbd_meta_device
      drbd_backing_device + "_meta"
    end

    # Map the DRBD to a physical device - will detach first.  This will
    # fail if the device is in use.
    #
    def drbd_attach!
      drbd.setup("detach")
      drbd.setup("disk", drbd_backing_device, drbd_meta_device, 0)
    end

    # Do the network setup for this machine's DRBD - will disconnect
    # and reconfigure each time, which should be harmless.
    #
    def drbd_connect!(extra_options=[])
      extra_options = [ extra_options ] unless extra_options.kind_of?(Array)
      drbd.setup("disconnect")
      drbd.setup("net", *(drbd_net_args + extra_options))
      drbd.setup("syncer", "-r", "20M")
    end

    # Returns a KVM object for tracking whether this Machine is actually
    # running or not.
    #
    def kvm
      @kvm ||= KVM.new(self)
    end

    # Returns the number of bytes for this VM's disc
    #
    def disc_size
      File.open(drbd_backing_device) { |fh| fh.seek(0,IO::SEEK_END); fh.tell }
    end

    def memory_dump_file
      "/machines/_#{name}_memory_dump"
    end

    protected
    def drbd_net_args
      [
      "#{Global.ips['here_drbd']}:#{drbd_port}",
      "#{Global.ips['there_drbd']}:#{drbd_port}",
        "B",
        "--after-sb-0pri", "discard-zero-changes",
        "--after-sb-1pri", "consensus",
        "--after-sb-2pri", "disconnect"
      ]
    end
  end

  #
  # A class for parsing Debian's /etc/network/interfaces, looking for
  # netmask and gateway addresses on bridges or interfaces that are
  # attached to bridges.
  #
  class EtcNetworkInterfaces
    def initialize(file='/etc/network/interfaces')
      @file = file
    end

    def gateway(bridge)
      find_stanza(bridge, 'gateway')
    end

    def netmask(bridge)
      find_stanza(bridge, 'netmask')
    end

  private

    def find_stanza(bridge, stanza)
      br = stanzas(bridge)
      if br && br[stanza]
        br[stanza].first
      else
        if br && br['bridge-ports']
          port = stanzas(br['bridge-ports'].first)
          if port && port[stanza]
            port[stanza].first
          end
        end
      end
    end

    def stanzas(iface)
      result = nil
      File.read(@file).each_line { |line|
        line.chomp!
        if result
          case line
          when /^\s*iface\s/, /^\s*mapping\s/, /^\s*auto\s/, /^\s*allow-/
            break
          when /^\s*(#.*)?$/
            next
          else
            key = line[/^\s*([\w-]+)/, 1]
            result[key] ||= []
            result[key] << line[/^\s*[\w-]+\s+(.*)(#.*)?$/, 1]
          end
        else
          next unless line =~ /^\s*iface\s+#{iface}(\s.*)?$/
          result = Hash.new
        end
      }

      result
    end
  end

  # Command line parser
  #
  module Commands
    class << self
      # Report an error and stop running
      #
      def error(msg, exception=nil)
        # RuntimeErrors are conditions we catch and raise ourselves
        if exception && (@verbose || !exception.kind_of?(RuntimeError))
          STDERR.print "*** #{exception}\n"
          exception.backtrace.each do |line|
            STDERR.print "* #{line}\n"
          end
        end
        STDERR.print("*** #{msg}\n")
        exit 1
      end

      #
      #
      def verbose(msg)
        STDERR.print "#{msg}\n" if @verbose
      end

      # Changes system to throw an exception if it fails
      #
      def system(*args)
        args = args.map { |a| a.to_s }
        if !Kernel::system(*args)
          STDERR.print "*** Error running #{args.join(' ')}\n"
          exit 2
        else
          verbose "system: "+args.join(" ")
          true
        end
      end

      # Turn our command line into execution of a method
      #
      def parse(*args)
        error("No command provided") if args.empty?
        if /-v|--verbose/.match(args[0])
          args.shift
          @verbose = true
        end
        args[0] = "help" if /-h|--help/.match(args[0])

        cmd = args.shift
        cmd_sym = "cmd_#{cmd}".to_sym
        error("No such command '#{cmd}' - Try #{$0} help") unless respond_to?(cmd_sym)
        begin
          __send__(cmd_sym, *args)
                    rescue ArgumentError => ex
          # assume the user can fix these, report them nicely
          help_sym = "help_#{cmd}".to_sym
          raise unless respond_to?(help_sym)
          error(ex.to_s + " - Try #{$0} help #{cmd}", @verbose ? ex : nil)
                    end
      end

      def help_help; [
        "Shows help",
        ["command"],
        [],
        { "command" => "The command you want help with " }
      ]; end

      def cmd_help(command=nil)
        if command
          # Show help on one command
          begin
            description, compulsory, optional, parameter_descriptions = *__send__("help_#{command}".to_sym)
          rescue NoMethodError => nme
            error "No such command '#{command}', type '#{$0} help' for the list"
          end

          print "Syntax: #{$0} #{command} "
          print compulsory.map { |param| "<#{param}> " }.join
          print optional.map   { |param| "[#{param}] " }.join
          print "\n\n#{description}\n\n"

          (compulsory+optional).each do |param|
            printf "%16s - %s\n", param, parameter_descriptions[param]
          end
        else
          # Show general help
          print "Syntax: #{$0} [--verbose] <command> ...\n\n"+
            "Where <command> is one of:\n\n"

          commands = methods.map { |m| /^help_(.*)/.match(m) ? $1 : nil }.compact.sort

          commands.each do |command|
            description, compulsory, optional, parameter_descriptions = *__send__("help_#{command}".to_sym)

            printf "  %10s ", command
            print compulsory.map { |param| "<#{param}> " }.join
            print optional.map   { |param| "[#{param}] " }.join
            print "\n"
          end
        end
      end

            def help_create; [
            "Creates a new virtual machine",
              ["name", "here|there|IP", "memory", "disc_size"],
                ["ip", "bridge", "drbd_port", "kvm_options", "vnc_screen", "--no-ssh-to-peer"],
                { "name" => "The name of the VM (15 chars max)",
                  "here|there|IP" => "The IP of the machine to run on (or 'here' or 'there')",
                  "memory" => "The number of megabytes of memory to allocate",
                  "disc_size" => "The size of disc to allocate (include suffix, e.g. 50G)",
                  "ip" => "The IP address to use (default is to auto-allocate)",
                  "bridge" => "Ethernet bridge to use (default is br0)",
                  "drbd_port" => "The DRBD port to use (default is to auto-allocate)",
                  "kvm_options" => "Any permanent KVM options for this VM (default is empty)",
                  "vnc_screen" => "The VNC screen number (default is to auto-allocate)",
                  "--no-ssh-to-peer" => "Don't connect via SSH to peer to run the same command"
                }
          ]; end

      def cmd_create(name, here_or_there, mem, disc_size, ip=nil, bridge=nil, drbd_port=nil, kvm_options="", vnc_screen=nil, no_ssh_to_peer=nil)

        check_system

        error("Include suffix with disc_size, e.g. 50G") unless
          disc_size =~ /[MGTPE]$/

        if here_or_there == Global.ips['here'].to_s
          here_or_there = "here"
        elsif here_or_there == Global.ips['there'].to_s
          here_or_there =  "there"
        elsif !/^t?here$/.match(here_or_there)
          error("Must supply 'here' or 'there' or IP address ('#{here_or_there}' is none of those)")
        end

        is_here = (here_or_there == "here")
        mem = mem.to_i

        # This seems clearer, why didn't I do this the first time?
        #
        # Leaving the logic below commented out in case I remember.
        #
        mem_used = Machine.total_memory_here + Machine.total_memory_there
        if mem_used + mem > Global.max_memory
          error("You've used #{mem_used}/#{Global.max_memory}M, so I can't allocate #{mem}M")
        end

        #mem_left = Global.max_memory/2 - (is_here ? Machine.total_memory_here : Machine.total_memory_there)
        #error("Won't use >50% of the memory on this host (must be < #{mem_left}M)") if
        #  is_here && Machine.total_memory_here + mem > Global.max_memory/2
        #error("Won't use >50% of the memory on the other host  (must be < #{mem_left}M)") if
        #  !is_here && Machine.total_memory_there + mem > Global.max_memory/2

        drbd_port = nil if drbd_port == "auto"
        vnc_screen = nil if vnc_screen == "auto"

        drbd_port ||= Machine.allocate_drbd_port
        vnc_screen ||= Machine.allocate_vnc_screen
        ip ||= Machine.allocate_ip
        bridge ||= 'br0'
        no_ssh_to_peer = (no_ssh_to_peer == "--no-ssh-to-peer")

        error("No DRBD ports left to allocate") unless drbd_port
        error("No VNC screens  left to allocate") unless vnc_screen
        error("No IP addresses left to allocate") unless ip
        error("No such bridge: #{bridge}") unless
          File.directory?("/sys/class/net/#{bridge}/bridge")

        # Create our logical volumes - 128MB fixed metadata

        verbose "creating #{name}"
        machine = Machine.new(name, {
          "ip" => ip,
          "bridge" => bridge,
          "suppress" => 1,
          "home_machine" => Global.ips[is_here ? 'here' : 'there'].to_s,
          "drbd_port" => drbd_port.to_i,
          "kvm_options" => kvm_options,
          "vnc_screen" => vnc_screen.to_i,
          "memory" => mem
        })

        # drbd name seems to be ignored for the 'create-md'
        # command, but it needs to be valid, and not configured.
        #
        system("/sbin/lvcreate -n#{name} -L#{disc_size} #{here_or_there}")
        system("/sbin/lvcreate -n#{name}_meta -L128M #{here_or_there}")
        system("/sbin/drbdmeta --force /dev/drbd9999999999 "+
          "v08 #{machine.drbd_meta_device} 0 create-md"
        )

        verbose "running drbd setup"
        machine.drbd_attach!
        machine.drbd_connect!

        # Need to wait for DRBD to get in gear before going further
        error "DRBD in unexpected state: #{machine.drbd.cs}" unless
          machine.drbd.wait_for_states("WFConnection", "Connected", "SyncSource", "SyncTarget")

        machine.drbd.setup("primary", "-o") if machine.at_home?

        if !no_ssh_to_peer
          verbose("ssh to other host")
          # Now do the same on the other host
          #
          ssh_command  = ["ssh", Global.ips['there'], $0]
          ssh_command += ["-v"] if @verbose
          ssh_command += [
            "create",
            name,
            Global.ips[is_here ? 'here' : 'there'].to_s, # specify same host!
            mem,
            disc_size,
            ip,
            bridge,
            drbd_port,
            '"'+kvm_options+'"',
            vnc_screen,
            "--no-ssh-to-peer" # avoid a loop thanks
          ]
          system(*ssh_command)

          error("DRBD didn't connect to peer properly, please investigate") unless
            machine.drbd.wait_for_states("Connected", "SyncSource", "SyncTarget")
        end
      end

      def help_destroy; [
        "Destroys a virtual machine on this machine and its peer (DANGER!)",
        ["name"],
        ["--no-ssh-to-peer"],
        { "name" => "The name of the VM",
                  "--no-ssh-to-peer" => "Don't connect via SSH to peer to run the same command"
        }
      ]; end

      def cmd_destroy(name, no_ssh_to_peer=nil)

        check_system

        machine = Machine.new(name)
        no_ssh_to_peer = (no_ssh_to_peer == "--no-ssh-to-peer")
        machine.kvm.stop! if machine.kvm.running?
        machine.drbd.setup("down") if machine.drbd.configured?
        system("/sbin/lvremove", "-f", machine.drbd_backing_device)
        system("/sbin/lvremove", "-f", machine.drbd_meta_device)
        is_at_home = machine.at_home? # about to destroy machine
        File.unlink("/machines/#{machine.name}")
        system("ssh", Global.ips['there'], $0, "destroy", name, "--no-ssh-to-peer") unless no_ssh_to_peer
      end

      def help_swap; [
        "Move a VM to the other server (very slow, copies data)",
        ["name"],
        [],
        { "name" => "The name of the VM to move" }
      ]; end

      def cmd_swap(name)
        check_system

        machine = Machine.new(name)
        machine.lock
        machine.drbd_attach! unless machine.drbd.configured?
        machine.drbd_connect!
        error("You must run 'pairvm swap' from the home machine (i.e. the other one)") unless machine.at_home?
        error("Local disc copy is not up to date, you'll need to wait") unless machine.drbd.ds.split("/")[0] == "UpToDate"

        # Stops the VM here, destroys it fully on the other host, and almost
        # destroys it here (instead renames its backing volume).
        #
        machine.kvm.stop! if machine.kvm.running?
        machine.drbd.setup("down") if machine.drbd.configured?
        tmp_backing_device = machine.drbd_backing_device + "_moving_#{$$}"
        old_mem = machine.memory
        old_disc_size = "#{machine.disc_size >> 10}K"
        old_ip = machine.ip.to_s
        old_bridge = machine.bridge
        old_drbd_port = machine.drbd_port
        old_kvm_options = machine.kvm_options
        old_vnc_screen = machine.vnc_screen
        system("/sbin/lvrename", machine.drbd_backing_device, tmp_backing_device)
        system("/sbin/lvremove", "-f", machine.drbd_meta_device)
        File.unlink("/machines/#{machine.name}")
        system("ssh", Global.ips['there'], $0, "destroy", name, "--no-ssh-to-peer")

        # Now recreate the VM here from the old source data.  The create command
        # will prematurely start syncing the blank machine, so we stop it and
        # start again after copying the old data to the backing device.
        #
        # This is a slightly odd state of affairs, because we are creating a
        # machine 'there', but forcing ourselves into the primary state so that
        # our data overwrites that on the new "home" machine.
        #
        cmd_create(name, "there", old_mem, old_disc_size, old_ip, old_bridge,
          old_drbd_port, old_kvm_options, old_vnc_screen)
        machine.drbd.setup("down")
        system("dd", "if=#{tmp_backing_device}", "of=#{machine.drbd_backing_device}")
        system("/sbin/lvremove", "-f", tmp_backing_device)
        machine.drbd_connect!
        system("ssh", Global.ips['there'], $0, "split_brain_victim", name, "0")
      end
      
      def help_swaplive; [
        "Move a VM to the other server (live, doesn't move data)",
        ["name"],
        ["--away"],
        { "name" => "The name of the VM to move",
          "--away" => "You must set this if moving from the home machine"
        }
      ]; end

      def cmd_swaplive(name, away=nil)
        check_system
        machine = Machine.new(name)
        #machine.lock

        away = (away == "--away")

        error("Can't move if machine isn't running") unless machine.kvm.running?
        error("Must specify --away if moving from the home machine") if
          machine.at_home? && !away

        cmd = [ 
          "ssh",
          Global.ips['there'],
          $0,
          "chkconfig",
          "#{machine.name}",
          "#{machine.digest}",
        ].map { |a| a.to_s }
        error("Refusing to swaplive whilst there is a config mismatch") unless
          Kernel::system(*cmd)

        error("Can't move the machine until DRBD is connected and in sync") unless
          machine.drbd.wait_for_states("Connected")

        machine.kvm.monitor_cmd("stop")
        machine.kvm.monitor_cmd("migrate_set_speed 4095m")
        machine.kvm.monitor_cmd("migrate \"exec: pairvm_send_memory #{machine.name} #{Global.ips['there']}\"")
        migration_message = nil
        while !migration_message || /Migration status: active/ =~ migration_message
          migration_message = machine.kvm.monitor_cmd('info migrate')
          sleep 1
        end
        unless /Migration status: completed/ =~ migration_message
           machine.kvm.monitor_cmd("cont")
           error("KVM migration failed:\n#{migration_message}")
        end
        
        cmd_stop(machine.name)
        machine.drbd.setup("secondary")        

        # use --disconnected to avoid a connection back to ourselves and deadlock
        cmd = ["ssh", Global.ips['there'], $0, "start", "#{machine.name}", "--disconnected"]
        cmd += ["--away"] if away
        system(*cmd)
      end

      def cmd_send_memory(name, host)
        machine = Machine.new(name)
        (1..255).each { |fd| IO.for_fd(fd).close rescue nil }
        STDERR.reopen(File.open("/tmp/send_memory_stderr.#{name}.#{$$}", 'w'))
        exec("gzip -c | ssh #{host} cat \\\>#{machine.memory_dump_file}")
#        exec("gzip -c >/tmp/out")
      end

      def cmd_printconfig(name)
        check_system
        machine = Machine.new(name)
        puts machine.yaml
      end

      # handy secret command for manual drbd fiddling
      #
      def cmd_drbdsetup(name, *options)
        check_system
        machine = Machine.new(name)
        machine.lock
        machine.drbd.setup(*options)
      end

      def cmd_read(name, option)
        check_system
        print Machine.new(name).send(option.to_sym).to_s + "\n"
      end

      def help_start; [
        "Starts a virtual machine running on this host",
        ["name"],
        ["--away", "--disconnected", "--kvm-options"],
         { "name" => "The name of the VM",
           "--away" => "Force VM to run when not on its home machine",
         "--disconnected" => "Force VM to run without replicating to peer",
         "--kvm-options <options...>" => "Extra KVM options for this boot"
         }
      ]; end

      def cmd_start(name, *options)        
        check_system        
        machine = Machine.new(name)
        machine.lock

        away = false
        disconnected = false
        kvm_options = []

        while !options.empty?
          o = options.shift
          case o
            when "--away" then away = true
            when "--disconnected" then disconnected = true
            when "--kvm-options"
              kvm_options = options
              options = []
              break
            else
              error "Unknown option #{o}"
          end
        end

        verbose "starting #{name} #{machine.at_home? ? 'at home' : 'away'}"+
          " away=#{away} destroy_peer=#{disconnected}"

        error "#{name} is not meant to run here, you must add "+
          "'--away' to run it away from home" unless
          machine.at_home? || away

        machine.drbd.setup("down")
        machine.drbd_attach! unless machine.drbd.configured?
        machine.drbd_connect!

        # If we don't wait for DRBD to connect before we switch to primary,
        # we risk a split brain.
        #
        if !machine.drbd.wait_for_states("Connected")
          if machine.drbd.cs == "StandAlone"
            error "DRBD device #{machine.drbd.node} is StandAlone which "+
              "suggests a split brain.  Run 'split_brain_victim' on one peer "+
              "or the other to erase its data and resolve the situation."
          elsif !disconnected
            error "DRBD device #{machine.drbd.node} is not connected and in " +
              "sync - use --disconnected if you want to run without the " +
              "peer (risking split brain later)."
          end
        end

        # Push other host into secondary state
        #
        if !disconnected
          ssh_command  = ["ssh", Global.ips['there'], $0]
          ssh_command += ["-v"] if @verbose
          ssh_command += ["drbd_connect", machine.name]
          system(*ssh_command)
        end

        # Now this should work without error
        #
        machine.drbd.setup("primary")

        if !machine.kvm.running?
          print "Starting #{machine.name}\n"
          system "/usr/sbin/arping -q -s #{machine.macaddr} " +
            "-S #{machine.ip} -B -c 1 -i #{machine.bridge} -p || true"
          machine.unlock
          machine.kvm.start!(kvm_options)
        end
      end

          def help_tap_up; [
              "Used internally by qemu to start network interface after KVM startup",
                    ["name"],
                [],
                { "name" => "The name of the VM (and network interface)" }
              ]; end

      def cmd_tap_up(name)
        machine = Machine.new(name)
        system "/sbin/ip link set #{name} up promisc on"
        system "/usr/sbin/brctl addif #{machine.bridge} #{name}"
      end

          def help_tap_down; [
              "Used internally by qemu to stop network interface after KVM shutdown",
                ["name"],
                [],
                { "name" => "The name of the VM (and network interface)" }
          ]; end

      def cmd_tap_down(name)
        machine = Machine.new(name)
        system "/usr/sbin/brctl delif #{machine.bridge} #{name}"
        system "/sbin/ip link set #{name} down"
        # make sure the other host can become primary without a fight before
        # we switch off
        # FIXME: this is too early, kvm needs better supervision
        machine.drbd.setup("secondary")
      end
      

            def help_drbd_connect; [
              "Set up the DRBD for the given machine as a secondary (which can be promoted later)",
                ["name"],
                [],
                { "name" => "The name of the VM" }
            ]; end

      def cmd_drbd_connect(name, *extra_options)
        check_system

        machine = Machine.new(name)
        machine.lock
        machine.drbd_attach! unless machine.drbd.configured?
        machine.drbd_connect!(extra_options)
        machine.drbd.setup("secondary") unless machine.drbd.primary? 
      end

      def help_resize; [
        "Resize the given server's disc",
        ["name", "size"],
        [],
        { "name" => "The name of the VM",
          "size" => "The new size (either +, - or absolute size)",
          "--confirm-shrink" => "You'll need to supply this if you want to shrink the disc" }
      ]; end

      def parse_size(spec)
          return case spec[-1..-1]
          when /[kK]/ then spec.to_i << 10
          when /[mM0123456789]/ then spec.to_i << 20
          when /[gG]/ then spec.to_i << 30
          when /[tT]/ then spec.to_i << 40
          when /[pP]/ then spec.to_i << 50
          when /[eE]/ then spec.to_i << 60
          else
            error("Don't understand size spec #{spec}")
        end
      end

      def cmd_resize(name, new_size, confirm_shrink=nil)
        check_system
        machine = Machine.new(name)
        machine.lock
        machine.drbd_attach! unless machine.drbd.configured?
        machine.drbd_connect!
        current_size_k = machine.disc_size >> 10
        new_size_k = case new_size[0]
          when ?+ then (current_size_k << 10) + (parse_size(new_size[1..-1]))
          when ?- then (current_size_k << 10) - (parse_size(new_size[1..-1]))
          when ?0..?9 then parse_size(new_size)
          else
            error("Don't understand size")
        end >> 10

        return if new_size_k == current_size_k
        confirm_shrink = (confirm_shrink == "--confirm-shrink")
        error("You must supply --confirm-shrink if you intend to shrink this disc") unless
          new_size_k > current_size_k || confirm_shrink
        error("Can't resize the disc until DRBD is connected and in sync") unless
          machine.drbd.wait_for_states("Connected")

        if new_size_k > current_size_k
          system("/sbin/lvresize", "--size", "#{new_size_k}K", machine.drbd_backing_device)
          system("ssh", Global.ips['there'], "lvresize", "--size", "#{new_size_k}K", machine.drbd_backing_device_there)
          machine.drbd.setup("resize")
        else
          error("Sorry, shrinking not implemented yet")
        end
      end

            def help_split_brain_victim; [
              "Designate the VM data on this host as a 'split brain victim' and erase it to resume replication",
                ["name"],
                  [],
        { "name" => "The name of the VM" ,
                  "snapshot_size" => "The size of the snapshot to create before erasing the data (default 2G, say '0' if you just want to erase it)"
                }
            ]; end

      def cmd_split_brain_victim(name, snapshot_size="2G")
        check_system
        machine = Machine.new(name)
        machine.lock

        error("Cannot fix split-brain with locally running VM") if machine.kvm.running?

        if snapshot_size != "0"
          lv_name = machine.name + "_split_" +
            Time.now.strftime("%Y%m%d%H%M%S")
          system("/sbin/lvcreate -n#{lv_name} -L#{snapshot_size} -s #{machine.drbd_backing_device}")
        end

        machine.drbd.setup("down")
        machine.drbd_connect!("--discard-my-data") # do the damage now we have a backup

        verbose "Created snapshot #{lv_name}, original will now be overwritten by peer"
      end

            def help_stop; [
              "Immediately kill the given VM (power off)",
        ["name"],
                  [],
                { "name" => "The name of the VM" }
            ]; end

      def cmd_stop(name)
        check_system
        Machine.new(name).kvm.stop!
      end


            def help_autostart; [
              "Start all VMs and DRBD connections that should run on this peer",
        [],
                  ["names ..."],
                { "names ..." => "Names of VMs to start automatically (default is all of them)" }
            ]; end

      def cmd_autostart(*names)
        check_system

        machines = names.empty? ? Machine.all : names.map { |m| Machine.new(m) }
        machines.each do |machine|
          begin
            if machine.at_home?
              cmd_start(machine.name) unless machine.kvm.running? ||
                machine.suppress?
            else
              cmd_drbd_connect(machine.name) unless machine.drbd.configured?
            end
          rescue Exception => ex
            error("Could not autostart VM #{machine.name}", ex)
          end
        end
      end

      def help_suppress; [
        "Suppress the given VM from starting automatically",
        ["name", "do_suppress"],
        [],
        { "name" => "The name of the VM",
          "do_suppress" => "1 to suppress, 0 to start automatically" }
      ]; end

      def cmd_suppress(name, do_suppress)
        check_system
        Machine.new(name).suppress(do_suppress == "1")
      end

      def help_monitor; [
        "Start the qemu system monitor for the given VM (advanced, see 'man kvm')",
        ["name", "command"],
        [],
        { "name" => "The name of the VM",
          "command" => "The KVM command to run"
        }
      ]; end

      def cmd_monitor(name, *command_args)
        check_system
        if command_args.empty?
          print "*** Press Ctrl+C to exit ('quit' will kill the machine) ***\n"
          exec("/usr/bin/socat", "-", Machine.new(name).kvm.monitorfile)
        else
          print Machine.new(name).kvm.monitor_cmd(command_args.join(" "))
        end
      end

      def help_cdrom; [
        "Check, insert or eject a CD-ROM from the given machine",
        ["name", "file"],
        [],
        { "name" => "The name of the VM",
          "file" => "The filename or URL to insert, or 'eject'" }
      ]; end

      def cmd_cdrom(name, spec=nil)
        kvm = Machine.new(name).kvm

        # Find out what's in there first
        raw = kvm.monitor_cmd("info block")
        raw_line = raw.split("\r\n").select { |x| /^ide1-cd0:/.match(x) }[0]
        error("No IDE CD-ROM detected in this machine") unless raw_line
        file = /file=([^ ]+) /.match(raw_line) ? $1 : nil

        print case spec
              when "eject"
                kvm.monitor_cmd("eject ide1-cd0")
              when nil
                if file
                  "Inserted: #{file}\n"
                else
                  "Empty\n"
                end
              else
                kvm.monitor_cmd("change ide1-cd0 #{spec}")
              end
      end

      def help_list; [
        "List the VMs running on this host and its peer",
        [],
        ["param"],
        {"param"=>"The machine parameter to list (or multiple,separated by commas)"}
      ]; end

      def cmd_list(param=nil)
        check_system

        list = Machine.all
        if list.empty?
          print "No machines configured yet.\n"
          return
        end
        print "Name            Memory Disc Run?    Home?   VNC  Disc state MAC\n" unless param
        list.each do |machine|
          if param
            print param.split(",").map { |p2| machine.send(p2.to_sym) }.
              join(" ") + "\n"
          else
            printf "%-15s %-6s %-4s %-s %-s :%-3d %-10s %s\n",
              machine.name,
              machine.memory.to_s + "M",
              (machine.disc_size >> 30).to_s + "G",
              machine.kvm.running? ?  "Running" : "Stopped",
              machine.at_home? ? "at home" : "away   ",
              machine.vnc_screen,
              machine.drbd.configured? ? machine.drbd.cs : "Not set up",
              machine.macaddr
            end
        end

        print "\nTotal RAM here: #{Machine.total_memory_here}M "+
          "there: #{Machine.total_memory_there}M "+
          "max: #{Global.max_memory}M\n" unless param
      end

      def help_graphite_stats; [
        "Generate statistics for graphite",
        ["prefix"],
        ["sendto"],
        { "prefix" => "The prefix to use for statistics",
          "host" => "The hostname or IP address to which to send stats"
         }
      ]; end
      
      def cmd_graphite_stats(prefix, sendto=nil)
        
        out = if sendto
          ip, port = sendto.split(":")
          port = port.to_i
          TCPSocket.new(ip, port)
        else
          STDOUT
        end
        
        now = Time.now.to_i
        machines = Machine.all.select { |m| m.kvm.running? }
        machines.each do |m|
          m_prefix = "#{prefix}.pairvm.#{m.name}"
        
          %w( ns nr dw dr al bm lo pe ua ap ep oos ).each do |stat|
            out.print m_prefix+".drbd.#{stat} #{m.drbd.__send__(stat.to_sym)} #{now}\n"
          end
          
          pid_stats = File.open("/proc/#{m.kvm.pid}/stat").read(2000).split(" ")
          out.print m_prefix+".utime #{pid_stats[13]} #{now}\n"
          out.print m_prefix+".stime #{pid_stats[13]} #{now}\n"
        end
        
        h_prefix = "#{prefix}.#{`hostname -s`.chomp}"
        
        load1, load5, load15, rest = File.read("/proc/loadavg").
          split(" ", 4)[0..2]
        out.print "#{h_prefix}.load1 #{load1} #{now}\n"
        out.print "#{h_prefix}.load5 #{load5} #{now}\n"
        out.print "#{h_prefix}.load15 #{load15} #{now}\n"
        
        out.close
      end

      def help_backup_snapshot; [
        "Snapshot & copy the given VM(s) to the given (SSH) destination.",
        ["name", "destination", "speed"],
        ["--home"],
        {"name" => "name of VM to back up (or 'all')",
         "destination" => "directory or filename destination as in 'user@hostname:/path' with _NAME replaced by VM name if present",
         "speed" => "Speed to limit copy in KB/s",
         "--home" => "force backup of machine(s) at home (performance penalty)"
        }
      ]; end

      class BackupFailedException < Exception; end
      
      def cmd_backup_snapshot(name, destination, speed, home_flag=false)
        home_flag = home_flag==true || home_flag=='--home'
        
        machines = Machine.all.
          select { |m| m.away? || (m.at_home? && home_flag) }.
          select { |m| name == 'all' || m.name == name }
        
        raise "No #{home_flag ? 'home' : 'away'} machine found '#{name}'" if
          machines.empty?
        
        machines.each do |m|
          snapshot_path = m.drbd_backing_device + "_" + Time.now.to_i.to_s
          snapshot_name = snapshot_path.split("/")[-1]
          destination_host, destination_path = destination.split(":", 2)
          
          begin
            raise BackupFailedException.new unless
              system "/sbin/lvcreate --size 4G --snapshot "+
              "--name #{snapshot_name} #{m.drbd_backing_device} >/dev/null"

            begin
              this_destination_path = destination_path.gsub("_NAME", m.name)
              temp_path = this_destination_path + ".tmp." + snapshot_name
              started = Time.now
              raise BackupFailedException.new unless
                system "gzip -c #{snapshot_path} | cpipe -s #{speed} | "+
                "ssh #{destination_host} cat \\> "+
                "#{temp_path} \\&\\& "+
                "mv #{temp_path} #{this_destination_path}"
              
              size = File.open(snapshot_path, "r") do |fh| 
                fh.seek(0,IO::SEEK_END); fh.tell >> 20
              end
              duration = (Time.now - started).to_i
            ensure
              system "/sbin/lvremove --force #{snapshot_path} >/dev/null"
            end
          rescue BackupFailedException => fail
            STDERR.print "^^^ Backup for #{m.name} failed\n"
          end
        end
      end

      def help_print_ssh_forwards; [
        "Print a list of SSH port forward specifications to access the consoles of any VM on this peer",
        ["offset"],
        [],
        { "offset" => "VNC screen offset on your local machine" }
      ]; end

      def cmd_print_ssh_forwards(offset=0)
        check_system

        offset = offset.to_i
        print "OpenSSH port forwards: "
        num = 0
        machines = Machine.all.select { |m| m.kvm.running? }.sort { |a,b| a.vnc_screen <=> b.vnc_screen }
        machines.each do |machine|
          print "-L #{5900+offset+num}:localhost:#{5900+machine.vnc_screen} "
          num += 1
        end
        print "\n\n"
        num = 0
        machines.each do |machine|
          print "#{machine.name} is on VNC localhost:#{offset+num}\n"
          num += 1
        end
      end

      def help_first_time_setup
        ["Initialise pairvm on a new system (interactive)",
        [],
        [],
        {"--force" => "Force setup even if it looks done (dangerous)"}
        ]
      end

      def cmd_first_time_setup(force=nil)
        error("Looks like setup is already done!  Use --force if you're sure") if
          force!="--force" && File.exists?("/machines/_global")

        print <<-HELLO
Setting up pairvm!  You will need to have set your IP addresses first,
and then you can tell me about them.  I'll prompt you if something
doesn't look right.

HELLO
        check_system

        ips = {}

        [["public", "Range of public IP addresses for VMs"],
        ["here", "This machine's IP address"],
        ["there", "The other machine's IP address"],
        ["here_drbd", "This machine's DRBD IP address"],
        ["there_drbd","The other machine's DRBD IP address"]].each do |ref, description|

          print "#{description}: "
          response = STDIN.readline.chomp

          check = nil
          begin
            check = IPAddr.new(response)
            raise ArgumentError.new("Must be IPv4") unless check.ipv4?
          rescue ArgumentError => ae
            STDERR.print "Not a valid IPv4 address\n"
            redo
          end

          if ref[0..4] == "here"
            begin
              TCPServer.new(response, 44444).close
            rescue Errno::EADDRNOTAVAIL
              STDERR.print "You must configure that address before you can use it\n"
              redo
            end
          end

          ips[ref] = response
        end

        Dir.mkdir("/machines") unless File.directory?("/machines")
        File.open("/machines/_global", "w") do |fh|
          fh.write({
                    "drbd_ports" => "45000-46000",
                    "ips" => ips
                  }.
                  to_yaml)
        end

        error("Problem generating an SSH key for root") unless
          Kernel::system("ssh-keygen -f ~/.ssh/id_rsa -q -P \"\"")

        print "You'll need to enter the root password to the other system to install the SSH key...\n"

        Dir.chdir(ENV['HOME'])

        File.open(".ssh/authorized_keys", "a+") do |fh|
          fh.print "from=\"#{ips['here']},#{ips['there']}\" "
          fh.print File.read(".ssh/id_rsa.pub")
          fh.print "\n"
          fh.chmod(0600)
        end

        error("Problem copying the SSH credentials across") unless
          Kernel::system("tar c .ssh/id_rsa .ssh/id_rsa.pub .ssh/authorized_keys "+
                        "| ssh #{ips['there']} tar x")

        print <<-DONE
Looks good!  Now do the same on #{ips['there']}, making sure to swap
'here' and 'there' values around.
DONE

      end

      def help_serial; [
        "Connect to a running VM's serial port",
        ["name"],
        ["escape"],
        {
          "name" => "The name of the VM",
          "escape" => "character code to disconnect (default 29: CTRL-])"
        }
      ]; end

      def cmd_serial(name, escape=29)
        check_system

        machine = Machine.new(name)
        error("Machine is not running") unless machine.kvm.running?
        error("Missing serial socket - machine needs to be restarted") unless
          File.exists?(machine.kvm.serialfile)

        puts 'Press CTRL-] to disconnect...' if escape == 29
        exec('/usr/bin/socat',
          "UNIX-CONNECT:#{machine.kvm.serialfile}",
          "STDIO,raw,echo=0,escape=#{escape}")
      end

      def help_image; [
        "Install an operating system image into a stopped VM",
        ["name", "dist", "hostname", "password"],
        ["firstboot-script"],
        {
          "name" => "The name of the VM",
          "dist" => "The distribution to install",
          "hostname" => "The fully qualified hostname of the VM",
          "password" => "The root password for the VM",
          "firstboot-script" => "A script to run in the VM on first boot"
        }
      ]; end

      def cmd_image(name, dist, hostname, password, firstboot_script = nil)
        error("bytemark_imager gem not installed") unless defined?(PairvmImager)

        check_system

        machine = Machine.new(name)

        error("#{name} is not meant to run here, you must image "+
          "it from there") unless machine.at_home?
        
        kvm = machine.kvm
        error("Cannot image running VM") if kvm.running?

        if machine.bridge == 'br0'
          gateway = Global.ips['public'].succ.to_s
          netmask = Global.ips['public'].inspect[/\/([0-9.]+)>/, 1]
                                         # ^ yuck - FIXME
        else
          # For any bridge other than br0 we try to guess the netmask
          # and gateway by looking in /etc/network/interfaces.
          #
          # FIXME: this is a bit clunky. There's go guarantee that the
          # information we need is available in /etc/network/interfaces
          # or that it reflects the current network configuration. It
          # might be better to pass the netmask and gateway as arguments.
          
          etc_network_interfaces = EtcNetworkInterfaces.new
          gateway = etc_network_interfaces.gateway(machine.bridge)
          netmask = etc_network_interfaces.netmask(machine.bridge)

          error 'Unable to work out the netmask for this machine.' +
            'Trying adding it to /etc/network/interfaces.' unless netmask

          gateway = machine.ip.mask(netmask).succ.to_s unless gateway
        end

        
        machine.drbd.setup("down")
        machine.drbd_attach! unless machine.drbd.configured?
        machine.drbd_connect!

        # If we don't wait for DRBD to connect before we switch to primary,
        # we risk a split brain.
        #
        if !machine.drbd.wait_for_states("Connected", "SyncSource", "SyncTarget")
          if machine.drbd.cs == "StandAlone"
            error "DRBD device #{machine.drbd.node} is StandAlone which "+
              "suggests a split brain.  Run 'split_brain_victim' on one peer "+
              "or the other to erase its data and resolve the situation."
          else
            error "DRBD device #{machine.drbd.node} is not connected "
          end
        end

        # Push other host into secondary state
        ssh_command  = ["ssh", Global.ips['there'], $0]
        ssh_command += ["-v"] if @verbose
        ssh_command += ["drbd_connect", machine.name]
        system(*ssh_command)

        # Now this should work without error
        #
        machine.drbd.setup("primary")
        
        options = {
            :dist => dist,
            :password => password,
            :hostname => hostname,
            :ip_address => machine.ip.to_s,
            :ip_gateway => gateway,
            :ip_netmask => netmask
        }
        if firstboot_script
          options[:firstboot_script] = begin
            File.read(firstboot_script)
          rescue
            error("Could not read firstboot_script")
          end
        end
        imager = PairvmImager.new(machine.drbd.node, options)
        error("Imaging failed") unless imager.install
        puts "#{dist} installed on #{name}."
      end

      def cmd_chkconfig(name, sum)
        check_system

        machine = Machine.new(name)
        
        exit machine.digest == sum ? 0 : 1
      end

      def check_system
        error("kvm isn't installed") unless
          File.executable?("/usr/bin/kvm")

        error("arping isn't installed") unless
          File.executable?("/usr/sbin/arping")

        error("socat isn't installed") unless
          File.executable?("/usr/bin/socat")

        error("cpipe isn't installed") unless
          File.executable?("/usr/bin/cpipe")

        error("kpartx isn't installed") unless
          File.executable?("/sbin/kpartx")

        error("You must configure a public bridge called br0 for public IP addresses") unless
          File.directory?("/sys/class/net/br0")

        # display "wrong media type" when scanning unconfigured drbds
        volume_groups = `/sbin/vgdisplay -c 2>&1`.split("\n").
          map { |l| l.split(":")[0].lstrip }

        error("You must configure volume groups called 'here' and 'there'") unless
          volume_groups.include?("here") &&
          volume_groups.include?("there")

        error("You must install drbd8-utils") unless
          File.executable?("/sbin/drbdsetup")

        error("You must symlink drbdadm to /bin/true - it gets in the way!") unless
          File.symlink?("/sbin/drbdadm") &&
          File.readlink("/sbin/drbdadm") == "/bin/true"

        system("/sbin/modprobe drbd") unless File.exists?("/proc/drbd")
      end


    end
  end
end

# shuts up LVM
ENV['LVM_SUPPRESS_FD_WARNINGS'] = "1"

me = File.expand_path($0)
if /pairvm_([a-z_]+)$/.match(me)
  PairVM::Commands.parse($1, *ARGV)
elsif File.exists?("/machines/_global")
  # Script must be callable by two aliases for qemu network scripts to work
  # - if this fails, you'll need to do it yourself.
  File.symlink(me, me+"_tap_up") unless File.symlink?(me+"_tap_up")
  File.symlink(me, me+"_tap_down") unless File.symlink?(me+"_tap_down")
  File.symlink(me, me+"_send_memory") unless File.symlink?(me+"_send_memory")

  PairVM::Commands.parse(*ARGV)
else
  STDERR.print "*** pairvm does not look initialised, please run #{$0} first_time_setup\n"
  PairVM::Commands.parse(*ARGV)
end


